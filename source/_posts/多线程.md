---
title: 多线程
date: 2022-06-29 17:07:11
tags: ['技术']
categories: 技术
---

### 1、 线程、进程、

#### 1、进程

**进程**(process)是程序的一次执行过程，或是正在运行的一个程序。是一个动态的过程：有它自身的产生、存在和消亡的过程。——生命周期

##### 1.1 进程之间的通信方式

1. 匿名管道通信
2. 高级管道通信
3. 有名管道通信
4.  消息队列通信
5. 信号量通信
6.  信号
7.  共享内存通信
8.  套接字通信

<!-- more -->

#### 2、线程

**线程**(thread)，进程可进一步细化为线程，是一个程序内部的一条执行路径。

​	一个Java应用程序java.exe，其实至少有三个线程：main()主线程，gc()垃圾回收线程，异常处理线程。当然如果发生异常，会影响主线程。

**线程的状态：**创建(new)、就绪(runnable)、运行(running)、阻塞(blocked、time waiting、waiting）、消亡（dead）。

​			time waiting（睡眠或等待一定的事件）、waiting（等待被唤醒）、blocked（阻塞）



**使用多线程的优点**

- 提高应用程序的响应。对图形化界面更有意义，可增强用户体验。
- 提高计算机系统CPU的利用率
- 改善程序结构。将既长又复杂的**进程**分为多个**线程**，独立运行，利于理解和修改



### 2、Thread类

> [Java并发编程：Thread类的使用 - Matrix海子 - 博客园 (cnblogs.com)](https://www.cnblogs.com/dolphin0520/p/3920357.html?msclkid=c130e6bbb70c11ec9db92ab38c68f94b)

#### 2.1 创建一个新的线程

##### **方法1**：继承线程

```java
/*
    多线程创建的方法
    1、创建一个继承Thread的类
    2、重写Run方法---> 将此线程执行的操作写在run中
    3、创建Thread 的对象
    4、通过调用此方法的start()
 */
class PrimeThread extends Thread {
    @Override
    public void run() {
        for (int i = 0; i < 20; i++) {
            System.out.println(i + ",");
        }
    }
}

public class test01 {
    // 主线程  main
    public static void main(String[] args) throws IOException {
        PrimeThread primeThread = new PrimeThread();   // 创建新的线程
        primeThread.start(); // 启动新的线程，调用run方法

        // 主线程的中执行
        for (int i = 0; i < 20; i++) {
            System.out.println( "hello");
        }
    }
}
```

**注意点**

1.如果自己手动调用**run()方法**，那么就只是普通方法，**没有启动多线程模式**。

2.run()方法由JVM调用，什么时候调用，执行的过程控制都有操作系统的CPU调度决定。

3.**想要启动多线程，必须调用start方法**。

4.一个线程对象只能调用一次start()方法启动，如果重复调用了，则将抛出以上的异常IllegalThreadStateException。

##### **方法2：继承Runable()**

```java
class PrimeThread2 implements Runnable {
    @Override
    public void run() {
        for (int i = 0; i < 20; i++) {
            System.out.println(i + ",");
        }
    }
}

public class test01 {
    // 主线程  main
    public static void main(String[] args) throws IOException {
        // 方法1：创建新线程的
        PrimeThread primeThread = new PrimeThread();   // 创建新的线程
        primeThread.start(); // 启动新的线程

        // 方法2：创建新线程
        PrimeThread2 primeThread2 = new PrimeThread2();
        new Thread(primeThread2).start();   // 这里比较特殊了
        
        for (int i = 0; i < 20; i++) {
            System.out.println( "hello");
        }
    }
}
```

#### 2.2  Thread类常用方法

1. **void** **start():** 启动线程，并执行对象的run()方法
2. **run():** 线程在被调度时执行的操作
3. **String** **getName():** 返回线程的名称
4. **void** **setName(String** **name)**:设置该线程名称
5. **static Thread currentThread():** 返回当前线程。在Thread子类中就是this，**通常用于主线程和Runnable实现类** （给主线程命名）
6. **static** **void** **yield()**线程让步
   1. 暂停当前正在执行的线程，把执行机会让给优先级相同或更高的线程
   2. 若队列中没有同优先级的线程，忽略此方法
7. **join()** **：**当某个程序执行流中调用其他线程的 join() 方法时，调用线程将被阻塞，直到 join() 方法加入的 join 线程执行完为止
   1. 低优先级的线程也可以获得执行
8. **static** **void** **sleep(long** **millis)****：**(指定时间:毫秒)
   1. 令当前活动线程在指定时间段内放弃对CPU控制,使其他线程有机会被执行,时间到后重排队。
   2.  抛出InterruptedException异常
9. **stop():** 强制线程生命期结束，不推荐使用
10. **boolean** **isAlive()**：返回boolean，判断线程是否还活着

##### wait()和sleep()的区别

- wait()方法会释放占有的对象锁，当前线程进入等待池，释放cpu,而其他正在等待的线程即可抢占此锁，获得锁的线程即可运行程序；
- 线程的sleep()方法则表示，当前线程会休眠一段时间，休眠期间，会暂时释放cpu，但并不释放对象锁，也就是说，在休眠期间，其他线程依然无法进入被同步保护的代码内部，当前线程休眠结束时，会重新获得cpu执行权,从而执行被同步保护的代码。
- **wait()和sleep()最大的不同在于wait()会释放对象锁，而sleep()不会释放对象锁。**

#### 2.3 线程的调度

1. 同优先级线程组成先进先出队列（先到先服务），使用时间片策略
2. 对高优先级，使用优先调度的抢占式策略

java中采用的是抢占式的策略，对于优先级高的会有更高的概率能够抢到cpu的使用权。

**线程的优先级等级**

​	MAX_PRIORITY：10

​	MIN _PRIORITY：1

​	NORM_PRIORITY：5

**涉及的方法**

​	**getPriority()** **：**返回线程优先值

​	**setPriority(int** **newPriority)** **：**改变线程的优先级

**说明**

   	线程创建时继承父线程的优先级

​		**低优先级只是获得调度的概率低，并非一定是在高优先级线程之后才被调用**

优先级的设定：

​	默认为  5

```java
MyThread myThread = new MyThread();
myThread.setPriority(10);
```

#### 2.4 线程的安全问题

JVM避免线程安全的问题主要从：**原子性、可见性、有序性** 三个方面展开。

原子性：操作**不能被线程调度机制中断**，要么**全部执行完毕**，**要么不执行**。

可见性：一个线程对共享变量做了修改之后，**其他的线程立即能够看到修改后的值**。

 有序性：即程序执行的顺序按照代码的先后顺序执行。

##### **2.4.1 方法1 同步代码块  同步机制 synchronized**

```java
synchronized (对象){
// 需要被同步的代码；
}
```

**注意： synchronized 的锁（对象）必须是唯一的，才能够实现线程安全**

示例1 ：**继承的线程实现** extends Thread

```java
//书写售票的示例
class Demo extends Thread{
    //定义变量记录剩余的票数
    int num = 100;

    //创建一个对象，用作同步中的锁对象
    Object obj = new Object();    //****** 这里的锁必须是唯一的

    //实现run方法
    @Override
    public void run()    {

        //实现售票的过程
        while( true )        {
            //   t1  t2  t3
            //判断当前有没有线程正在if中操作num，如果有当前线程就在这里临时等待
            //这种思想称为线程的同步
            //当票数小等于0的时候，就不再售票了
            //使用同步代码块把线程要执行的任务代码可以同步起来
            synchronized( obj )  //t1   在进入同步之前线程要先获取锁     ***** obj 锁唯一，不能是多个锁
            /*
                当某个线程执行到synchronized关键字之后，这时JVM会判断当前
                同步上的这个对象有没有已经被其他线程获取走了，如果这时没有其他
                线程获取这个对象，这时就会把当前同步上的这个对象交给当前正要进入
                同步的这个线程。
            */
            {
                if( num > 0 )
                {
                    //t0
                    try{Thread.sleep(2);}catch( InterruptedException e ){}
                    System.out.println(Thread.currentThread().getName()+"....."+num);
                    num--;
                }
            }//线程执行完同步之后，那么这时当前这个线程就会把锁释放掉
        }
    }
}
class ThreadDemo {
    public static void main(String[] args)     {
        //创建线程任务
        Demo d = new Demo();
        //创建线程对象
        Thread t = new Thread( d );
        Thread t2 = new Thread(d);
        Thread t3 = new Thread(d);
        Thread t4 = new Thread(d);
        //开启线程
        t.start();
        t2.start();
        t3.start();
        t4.start();
    }
}
```

##### **2.4.2 使用同步方法来实现**  

**继承的线程方法 **extends Thread 

```java
//书写售票的示例
class Demo extends Thread{
    //定义变量记录剩余的票数
    int num = 100;

    //实现run方法
    @Override
    public void run()    {
        while( true )        {
            show();  // 同步方法
        }
    }

    public synchronized void show() {
            if( num > 0 )
            {
                //t0
                try{Thread.sleep(2);}catch( InterruptedException e ){}
                System.out.println(Thread.currentThread().getName()+"....."+num);
                num--;
            }
    }
}
class ThreadDemo {
    public static void main(String[] args)     {
        //创建线程任务
        Demo d = new Demo();
        //创建线程对象
        Thread t = new Thread( d );
        Thread t2 = new Thread(d);
        Thread t3 = new Thread(d);
        Thread t4 = new Thread(d);
        //开启线程
        t.start();
        t2.start();
        t3.start();
        t4.start();
    }
}
```

**实现Runable的线程方法 **implements Runnable 

```java
//书写售票的示例
class Demo implements Runnable{
    //定义变量记录剩余的票数
    int num = 100;
    //实现run方法
    @Override
    public void run()    {
        while( true )        {
            show();  // 同步方法
        }
    }
    public static synchronized void show() {
            if( num > 0 )
            {
                //t0
                try{Thread.sleep(2);}catch( InterruptedException e ){}
                System.out.println(Thread.currentThread().getName()+"....."+num);
                num--;
            }
    }
}
class ThreadDemo {
    public static void main(String[] args)     {
        //创建线程任务
        Demo d = new Demo();
        //创建线程对象
        Thread t = new Thread( d );
        Thread t2 = new Thread(d);
        Thread t3 = new Thread(d);
        Thread t4 = new Thread(d);
        //开启线程
        t.start();
        t2.start();
        t3.start();
        t4.start();
    }
}
```

#### 2.5 懒汉式 的线程安全

```java
class Single
{
    private static Object obj = new Object();
    private Single() {}
    private static  Single s = null;
    public static Single getInstance()
    {
        // 方法1 
        /*synchronized (obj) {
            //先判断有没有对象
            if( s == null )   //判断最后线程进入同步之后到底有没有对象，只有在没有对象的情况下才能创建对象
            {
                s = new Single();
            }
            return s;
        }*/
        // 方法2 // 这种方法为什么效率高
        if( s == null )// 这里加判断的目的是保证后续来的线程不用在进入同步代码块中，这个可以提高后续程序效率
        {
            synchronized( obj )
            {
                //先判断有没有对象
                if( s == null )   //判断最后线程进入同步之后到底有没有对象，只有在没有对象的情况下才能创建对象
                {
                    s = new Single();
                }
            }
        }
        return s;
    }
}

```

#### 2.6 死锁

线程死锁是指两个或两个以上的线程互相持有对方所需要的资源，由于synchronized的特性，一个线程持有一个资源，或者说获得一个锁，在该线程释放这个锁之前，其它线程是获取不到这个锁的，而且会一直死等下去，因此这便造成了死锁。

演示：

```java
public class DeadLock {
    private  Object lock1 = new Object();
    private  Object lock2 = new Object();

    public  void method1() throws InterruptedException {
        synchronized(lock1){
            System.out.println(Thread.currentThread().getName() + "获取到lock1,请求获取lock2....");
            Thread.sleep(1000);
            synchronized (lock2){
                System.out.println("获取到lock2....");
            }
        }
    }
    public  void method2() throws InterruptedException {
        synchronized(lock2){
            System.out.println(Thread.currentThread().getName() + "获取到lock2,请求获取lock1....");
            Thread.sleep(1000);
            synchronized (lock1){
                System.out.println("获取到lock1....");
            }
        }
    }

    public static void main(String[] args) {
        DeadLock deadLock = new DeadLock();

        new Thread(()-> {
            try {
                deadLock.method1();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }).start();
        new Thread(()-> {
            try {
                deadLock.method2();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }).start();

    }
}
```

##### **如何避免死锁**

- 加锁顺序：线程按照相同的顺序加锁。

- 加锁时限，线程获取锁的过程中限制一定的时间，如果给定时间内获取不到，就算了，别勉强自己。

  ```
  lock2.tryLock(3, TimeUnit.SECONDS); // 等3s获取锁，获取不到也会继续向下走  lock表示线程
  ```

##### **如何来检查死锁**？

使用 jstack或者pstack 和 gdb 工具进行分析，输出栈堆信息

[Java如何查看死锁？_ZK_小姜的博客-CSDN博客_查看死锁](https://blog.csdn.net/u014039577/article/details/52351626)

1. **Jconsole查看死锁**

   进入java安装的位置，输入Jconsole，然后弹出界面（或者进入安装目录/java/jdk1.70_80/bin/，点击Jconsole.exe）：

#### 2.8 线程池

**线程池的种类**：lExecutors：工具类、线程池的工厂类，用于创建并返回不同类型的线程池

- Executors.newCachedThreadPool()：创建一个可根据需要创建新线程的线程池
- Executors.newFixedThreadPool(n); 创建一个可重用固定线程数的线程池
- Executors.newSingleThreadExecutor() ：创建一个只有一个线程的线程池
- Executors.newScheduledThreadPool(n)：创建一个线程池，它可安排在给定延迟后运行命令或者定期地执行。

```java
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.ThreadPoolExecutor;
import java.util.concurrent.TimeUnit;
public class ThreadPoolExecutorDemo {
    // 设置各个参数
    private static final int CORE_POOL_SIZE = 5;
    private static final int MAX_POOL_SIZE = 10;
    private static final int QUEUE_CAPACITY = 100;
    private static final Long KEEP_ALIVE_TIME = 1L;

    public static void main(String[] args) {
        ThreadPoolExecutor executor = new ThreadPoolExecutor(
                CORE_POOL_SIZE,
                MAX_POOL_SIZE,
                KEEP_ALIVE_TIME,
                TimeUnit.SECONDS,
                new ArrayBlockingQueue<>(QUEUE_CAPACITY),
                new ThreadPoolExecutor.CallerRunsPolicy()
        );
        for (int i = 0; i < 10; i++) {
            // 创建WorkerThread对象（该类实现了Runnable接口）
            Runnable worker = new MyRunnable("" + i);
            // 执行Runnable
            executor.execute(worker);
        }
        // 终止线程池
        executor.shutdown();
        while (!executor.isTerminated()) {
        }
        System.out.println("Finished all threads");
    }
}
```

线程池的属性：

1. **int corePoolSize** => 该线程池中**核心线程数最大值**
2. **int maximumPoolSize** **线程总数最大值**
3. **long keepAliveTime** **非核心线程闲置超时时长**
4. `threadFactory`（线程工厂）：用于创建工作线程的工厂。
5. `corePoolSize`（核心线程数）：当线程池运行的线程少于 corePoolSize 时，将创建一个新线程来处理请求，即使其他工作线程处于空闲状态。
6. `workQueue`（队列）：用于保留任务并移交给工作线程的阻塞队列。
7. `maximumPoolSize`（最大线程数）：线程池允许开启的最大线程数。
8. `handler`（拒绝策略）：往线程池添加任务时，将在下面两种情况触发拒绝策略：1）线程池运行状态不是 RUNNING；2）线程池已经达到最大线程数，并且阻塞队列已满时。
9. `keepAliveTime`（保持存活时间）：如果线程池当前线程数超过 corePoolSize，则多余的线程空闲时间超过 keepAliveTime 时会被终止。

```java
public class ThreadDemo {
    public static void main(String[] args) {
        ExecutorService executorService = Executors.newCachedThreadPool();  // 线程池的创建
        executorService.execute(new MyThread()); // 执行线程池
        executorService.shutdown(); // 关闭线程池
        
    }
}
class MyThread implements Runnable {
    @Override
    public void run() {
        for (int i = 0; i < 50; i++) {
            System.out.println(Thread.currentThread().getName() +":"+ i);
        }
    }
}
```

#### 2.9 线程的生命周期

​	![img](线程、多线程.assets/0cd26da3d92bb6aff1bab9555826e8e4.png)

**新建状态**（New）：当线程对象创建后就是进入到了新建状态，如：Thread t = new MyThread();

**就绪状态**（Runnable）：当调用线程对象的start()方法，线程即进入到了就绪状态。处于就绪状态的线程，只是说明此线程已经做好了准备，随时等待CPU调度执行，并不

是执行了start()此线程就会执行。

**运行状态**（Running）：当CPU调度处于就绪状态的线程的时候，此时线程才会得以真正的执行，即进入运行状态。

注：就绪状态是进入运行状态的唯一入口，也就是说线程进入运行状态的前提是已经进入到了就绪状态。

**阻塞状态**（Blocked）：处于运行状态的线程由于某种原因，暂时放弃对CPU的使用权，停止执行，此时进入阻塞状态，知道进入到就绪状态，才有机会再次被CPU调用以进

入到运行状态，根据产生阻塞状态的三原因，阻塞状态可以分为三种：

- 等待阻塞--》运行状态的线程执行wait()方法，使线程进入到阻塞状态
- 同步阻塞--》线程获取同步锁失败，因为同步锁被其他线程所占用，这时线程就会进入同步阻塞状态；
- 其他阻塞--》通过调用线程的sleep()或join()或发出了I/O请求的时候线程会进入阻塞状态，当sleep()状态超时，join()等待线程终止或者超时，或者I/O处理完毕，线程就会重新转入就绪状态。

**死亡状态**（Dead）：线程执行完了或者因一场退出了run()方法，该线程就结束了生命周期。

##### 多个线程之间的通信：

**wait()、notify()和 notifyAll()**

 [线程间的通信方式_LallanaLee的博客-CSDN博客_线程间的通信方式](https://blog.csdn.net/weixin_46217160/article/details/108743389)

- 使用wait()、notify()和notifyAll()需要先调用对象加锁
- 调用wait()方法后，线程状态由Running变成Waiting，并将当前线程放置到对象的等待队列
- notify()和notifyAll()方法调用后，等待线程依旧不会从wait()返回，需要调用notify()和notifyAll()的线程释放锁之后等待线程才有机会从wait()返回
- notify()方法将等待队列中的一个等待线程从等待队列中移到同步队列中，而notifyAll()方法则是将等待队列中所有的线程全部转移到同步队列，被移到的线程状态由Waiting变为Blocked。
- 从wait()方法返回的前提是获得调用对象的锁

#### 2.10 线程上下文切换

多个线程可以执行在单核或多核CPU上，单核CPU也支持多线程执行代码，CPU通过给每个线程分配CPU时间片(机会)来实现这个机制。CPU为了执行多个线程，就需要不停的切换执行的线程，这样才能保证所有的线程在一段时间内都有被执行的机会。

此时，CPU分配给每个线程的执行时间段，称作它的时间片。CPU时间片一般为几十毫秒。CPU通过时间片分配算法来循环执行任务，当前任务执行一个时间片后切换到下一个任务。

但是，在切换前会保存上一个任务的状态，以便下次切换回这个任务时，可以再加载这个任务的状态。所以`任务从保存到再加载的过程就是一次上下文切换。`

**根据多线程的运行状态来说明**：多线程环境中，当一个线程的状态由Runnable转换为非Runnable(Blocked、Waiting、Timed_Waiting)时，相应线程的上下文信息(包括CPU的寄存器和程序计数器在某一时间点的内容等)需要被保存，以便相应线程稍后再次进入Runnable状态时能够在之前的执行进度的基础上继续前进。而一个线程从非Runnable状态进入Runnable状态可能涉及恢复之前保存的上下文信息。这个对线程的上下文进行保存和恢复的过程就被称为上下文切换。

###  3、并行和并发

**并行：**多个CPU同时执行多个任务。比如：多个人同时做不同的事。

**并发：**一个CPU(采用时间片)同时执行多个任务。比如：秒杀、多个人做同一件事。

- 并发(concurrency)：指在同一时刻只能有一条指令执行，但多个进程指令被快速的轮换执行，使得在宏观上具有多个进程同时执行的效果，但在微观上并不是同时执行的，只是把时间分成若干段，使多个进程快速交替的执行。
- 并行(parallel)：指在同一时刻，有多条指令在多个处理器上同时执行。所以无论从微观还是从宏观来看，二者都是一起执行的。



